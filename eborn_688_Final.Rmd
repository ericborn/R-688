---
title: "2003-2004 NBA Analysis"
author: Eric Born - CS688 Final Project
output: html_document
---
```{r include = FALSE}
#############
# Start setup
#############

# Load libraries
library('XML')
library('rvest')
library('purrr')
library('plotly')
library('stringi')
library('googleVis')
library('SportsAnalytics')

###############
# a)
# 2003-2004

# b)
# pull down 2003-04 season stats
NBA.Stats <- fetch_NBAPlayerStatistics(season = "03-04", what = c("",".Home", ".Away"))

# c)
wolves <- NBA.Stats[NBA.Stats$Team == 'MIN',]

# Highest Total Points
points <- wolves[wolves$TotalPoints == max(wolves$TotalPoints),c(2, 21)]

# Highest Blocks
blocks <- wolves[wolves$Blocks == max(wolves$Blocks),c(2, 18)]

# Highest Rebounds
rebounds <- wolves[wolves$TotalRebounds == max(wolves$TotalRebounds),c(2, 14)]

# create df for basic stats
basic.stats <- data.frame("Player" = c(points[[1]], blocks[[1]], rebounds[[1]]),
                          "Stat" = c('Highest Points', 'Highest Rebounds', 'Highest Blocks'),
                          'Total' = c(points[[2]], rebounds[[2]], blocks[[2]]))

# reset factors to order by player column
basic.stats$Player <- factor(basic.stats$Player, 
                              levels = c(as.character(basic.stats$Player)))

# Convert factors to character
basic.stats$Player <- as.character(basic.stats$Player)

# reset factors to order by stat column
basic.stats$Stat <- factor(basic.stats$Stat, 
                             levels = c(as.character(basic.stats$Stat)))

# Convert factors to character
basic.stats$Stat <- as.character(basic.stats$Stat)


# create table for top 10 abv's, total reviews and average review score
stat.table <- plot_ly(
  type = 'table',
  height = 250,
  width = 700,
  header = list(
    values = c('Player', 'Stat', 'Total'),
    line = list(width = 1, color = 'black'),
    fill = list(color = c('#1f77b4', '#1f77b4')),
    font = list(famile = 'Arial', size = 14, color = 'white')
  ),
  cells = list(
    values = rbind(basic.stats$Player, basic.stats$Stat, basic.stats$Total),
    align = c('center'),
    line = list(width = 1, color = 'black')
  ))

# Output table
stat.table


# d)
# top 5 teams for the 03-04 season
season.url <- 'https://www.landofbasketball.com/yearbyyear/2003_2004_standings.htm'

# read the html
webpage <- read_html(season.url)

# create var to hold wins/losses for each conference
mid.wins <- c(0)
mid.loss <- c(0)
pac.wins <- c(0)
pac.loss <- c(0)
atl.wins <- c(0)
atl.loss <- c(0)
cen.wins <- c(0)
cen.loss <- c(0)

# midwest div 7 teams
# loop through the columns grabbing each win and loss
for (k in 2:8){
  mid.wins[[k]] <- webpage %>% html_nodes("table") %>% .[4] %>% 
    html_nodes("tr") %>% .[k] %>% html_nodes("td") %>% .[3] %>% html_text()
}

for (k in 2:8){
  mid.loss[[k]] <- webpage %>% html_nodes("table") %>% .[4] %>% 
    html_nodes("tr") %>% .[k] %>% html_nodes("td") %>% .[4] %>% html_text()
}

# pac div 7 teams
# loop through the columns grabbing each win and loss
for (k in 2:8){
  pac.wins[[k]] <- webpage %>% html_nodes("table") %>% .[5] %>% 
    html_nodes("tr") %>% .[k] %>% html_nodes("td") %>% .[3] %>% html_text()
}

for (k in 2:8){
  pac.loss[[k]] <- webpage %>% html_nodes("table") %>% .[5] %>% 
    html_nodes("tr") %>% .[k] %>% html_nodes("td") %>% .[4] %>% html_text()
}

# atl div 7 teams
# loop through the columns grabbing each win and loss
for (k in 2:8){
  atl.wins[[k]] <- webpage %>% html_nodes("table") %>% .[6] %>% 
    html_nodes("tr") %>% .[k] %>% html_nodes("td") %>% .[3] %>% html_text()
}

for (k in 2:8){
  atl.loss[[k]] <- webpage %>% html_nodes("table") %>% .[6] %>% 
    html_nodes("tr") %>% .[k] %>% html_nodes("td") %>% .[4] %>% html_text()
}

# cen div 8 teams
# loop through the columns grabbing each win and loss
for (k in 2:9){
  cen.wins[[k]] <- webpage %>% html_nodes("table") %>% .[7] %>% 
    html_nodes("tr") %>% .[k] %>% html_nodes("td") %>% .[3] %>% html_text()
}

for (k in 2:9){
  cen.loss[[k]] <- webpage %>% html_nodes("table") %>% .[7] %>% 
    html_nodes("tr") %>% .[k] %>% html_nodes("td") %>% .[4] %>% html_text()
}

# drop the 1st index which is an NA
mid.wins <- mid.wins[-1]
mid.loss <- mid.loss[-1]
pac.wins <- pac.wins[-1]
pac.loss <- pac.loss[-1]
atl.wins <- atl.wins[-1]
atl.loss <- atl.loss[-1]
cen.wins <- cen.wins[-1]
cen.loss <- cen.loss[-1]

# team names by conference and division
western <- webpage %>% html_nodes("table") %>% .[1] %>% html_nodes("a") %>% html_text()
eastern <- webpage %>% html_nodes("table") %>% .[2] %>% html_nodes("a") %>% html_text()
midwest <- webpage %>% html_nodes("table") %>% .[4] %>% html_nodes("a") %>% html_text()
pacific <- webpage %>% html_nodes("table") %>% .[5] %>% html_nodes("a") %>% html_text()
atlantic <- webpage %>% html_nodes("table") %>% .[6] %>% html_nodes("a") %>% html_text()
central <- webpage %>% html_nodes("table") %>% .[7] %>% html_nodes("a") %>% html_text()
teams <- c(midwest, pacific, atlantic, central)

# Create dataframe from win/loss data
teams.df = data.frame(Team=teams, 
                      Conference=c(rep('Western',length(western)),
                                   rep('Eastern',length(eastern))),
                      Division=c(rep('Midwest', length(midwest)),
                                 rep('Pacific', length(pacific)),
                                 rep('Atlantic', length(atlantic)),
                                 rep('Central', length(central))),
                      Win=c(mid.wins, pac.wins, atl.wins, cen.wins),
                      Loss=c(mid.loss,pac.loss,atl.loss,cen.loss))

# reset factors to order by Team column
teams.df$Team <- factor(teams.df$Team, 
                             levels = c(as.character(teams.df$Team)))

# Convert factors to character
teams.df$Team <- as.character(teams.df$Team)


# reset factors to order by stat column
teams.df$Conference <- factor(teams.df$Conference, 
                           levels = c(as.character(teams.df$Conference)))

# Convert factors to character
teams.df$Conference <- as.character(teams.df$Conference)

# reset factors to order by stat column
teams.df$Division <- factor(teams.df$Division, 
                              levels = c(as.character(teams.df$Division)))

# Convert factors to character
teams.df$Division <- as.character(teams.df$Division)

# reset factors to order by stat column
teams.df$Win <- factor(teams.df$Win, 
                            levels = c(as.character(teams.df$Win)))

# Convert factors to character
teams.df$Win <- as.character(teams.df$Win)

# reset factors to order by stat column
teams.df$Loss <- factor(teams.df$Loss, 
                       levels = c(as.character(teams.df$Loss)))

# Convert factors to character
teams.df$Loss <- as.character(teams.df$Loss)

# order by wins
teams.df <- teams.df[order(teams.df$Win, decreasing = TRUE),]

# grab just top 5 teams by wins
teams.df.five <- head(teams.df[order(teams.df$Win, decreasing = TRUE),], n=5)

# create table for all nba teams with their conference, div, win/loss
full.record.table <- plot_ly(
  type = 'table',
  height = 800,
  columnwidth = c(40, 30, 30, 15, 15),
  header = list(
    values = c('Team', 'Conference', 'Division', 'Win', 'Loss'),
    line = list(width = 1, color = 'black'),
    fill = list(color = c('#1f77b4', '#1f77b4')),
    font = list(famile = 'Arial', size = 14, color = 'white')
  ),
  cells = list(
    values = rbind(teams.df$Team, teams.df$Conference, teams.df$Division,
                   teams.df$Win, teams.df$Loss),
    align = c('center'),
    line = list(width = 1, color = 'black')
  ))

# Output table
full.record.table

# create table for top 5 nba teams
top.record.table <- plot_ly(
  type = 'table',
  height = 800,
  columnwidth = c(40, 30, 30, 15, 15),
  header = list(
    values = c('Team', 'Conference', 'Division', 'Win', 'Loss'),
    line = list(width = 1, color = 'black'),
    fill = list(color = c('#1f77b4', '#1f77b4')),
    font = list(famile = 'Arial', size = 14, color = 'white')
  ),
  cells = list(
    values = rbind(teams.df.five$Team, teams.df.five$Conference,
                   teams.df.five$Division, teams.df.five$Win, 
                   teams.df.five$Loss),
    align = c('center'),
    line = list(width = 1, color = 'black')
  ))

# Output table
top.record.table

# e)
# 1)
# plot top 10 points per team
# gather total points per team
top.points <- aggregate(TotalPoints ~ Team, data = NBA.Stats, FUN=sum)

# only select top 10 teams by total points
top10.points <- head(top.points[order(top.points$TotalPoints, decreasing = TRUE),], n=10)

# Reset rownames from 1 to n
rownames(top10.points) <- 1:nrow(top10.points)

# drop empty factor levels
top10.points <- droplevels(top10.points)

# 19 removed since it was NA team with 20 points
all.points <- aggregate(TotalPoints ~ Team, data = NBA.Stats, FUN=sum)[-19,]

# average points across all teams
avg.points <- mean(all.points$TotalPoints)

y <- list(title = "Total Points")
x <- list(title = 'Teams')
points.plot <- plot_ly(top10.points, x = ~Team, y= ~TotalPoints,
                       type='bar', color = ~Team)%>% 
  add_trace(y = avg.points, name = 'League Avg Points', type = 'scatter', 
            mode = 'lines', color = I('black'))%>%
  layout(yaxis = y, title = "Top 10 Total Points per Team", xaxis = x)

# draw plot
points.plot

# # 2)
# scorers breakdown for the wolves
# number of FieldGoalsMade, ThreesMade, FreeThrowsMade
wolves.points <- wolves[c(2,7,9,11)]

# Create boxplot based on top 10 beer styles with ABV information
y <- list(title = "Total Points")
x <- list(title = 'Players')
wolves.plot <- plot_ly(wolves.points, x = ~Name, y = ~FieldGoalsMade, type = 'bar', name = 'Field Goals')%>% 
  add_trace(y = ~ThreesMade, name =  'Threes' )%>%
  add_trace(y = ~FreeThrowsMade, name = 'Free Throws' )%>%
  layout(xaxis = x, yaxis = y, title = "Point Distribution of the Timber Wolves", barmode = 'stack')

# draw plot
wolves.plot

# 3)
# Box plot
# store just the top 10 scoring team names
teams <- as.vector(top10.points$Team)

# pull players team and total points from top 10
top10.full <- NBA.Stats[with(NBA.Stats,Team %in% teams),c(3,21)]

# Reset rownames from 1 to n
rownames(top10.full) <- 1:nrow(top10.full)

# drop empty factor levels
top10.full <- droplevels(top10.full)

# Create boxplot based on top 10 beer styles with ABV information
y <- list(title = "Total Points")
x <- list(title = 'Team')
top.box <- plot_ly(top10.full, x = ~Team, y = ~TotalPoints, type = 'box', size = 2,
                   color = ~Team)%>% 
  layout(xaxis = x, yaxis = y, title = "Point distribution of top 10 teams")

# draw plot
top.box

# 4)
# top 10 scorers
# number of FieldGoalsMade, ThreesMade, FreeThrowsMade

# players
players <- head(NBA.Stats[order(NBA.Stats$TotalPoints, decreasing = TRUE),c(2)], n=10)

# FieldGoalsMade, ThreesMade, FreeThrowsMade
player.points <- NBA.Stats[NBA.Stats$Name %in% players, c(2,7,9,11)]

# Create boxplot based on top 10 beer styles with ABV information
y <- list(title = "Total Points")
x <- list(title = 'Player')
players.plot <- plot_ly(player.points, x = ~Name, y = ~FieldGoalsMade, type = 'bar', name = 'Field Goals')%>% 
  add_trace(y = ~ThreesMade, name =  'Threes' )%>%
  add_trace(y = ~FreeThrowsMade, name = 'Free Throws' )%>%
  layout(xaxis = x, yaxis = y, title = "Point Distribution of the Top 10 Players", barmode = 'stack')

# draw plot
players.plot

# 5)
# score breakdown per top 10 teams
# players
teams <- head(NBA.Stats[order(NBA.Stats$TotalPoints, decreasing = TRUE),c(3)], n=10)

# FieldGoalsMade, ThreesMade, FreeThrowsMade
team.points <- NBA.Stats[NBA.Stats$Team %in% teams, c(3,7,9,11)]

# Reset rownames from 1 to n
rownames(team.points) <- 1:nrow(team.points)

# drop empty factor levels
team.points <- droplevels(team.points)

# Create boxplot based on top 10 beer styles with ABV information
y <- list(title = "Total Points")
x <- list(title = 'Team')
team.point.plot <- plot_ly(team.points, x = ~Team, y = ~FieldGoalsMade, type = 'bar', name = 'Field Goals')%>% 
  add_trace(y = ~ThreesMade, name =  'Threes' )%>%
  add_trace(y = ~FreeThrowsMade, name = 'Free Throws' )%>%
  layout(xaxis = x, yaxis = y, title = "Point Distribution of the Top 10 Teams", barmode = 'stack')

# draw plot
team.point.plot

# f)
# champ names

champ.url <- 'https://www.landofbasketball.com/championships/year_by_year.htm'

# read the html
champ.page <- read_html(champ.url)

# initalize vector
champ.names <- c(0)

# loop through page to get the last 20 NBA champs
for (k in 2:21){
  champ.names[[k]] <- champ.page %>% html_nodes("table") %>% .[1] %>% html_nodes("tr") %>% .[k] %>% 
    html_nodes("a") %>% .[2] %>% html_text()
}

# drop index 1
champ.names <- champ.names[-1]

# Makes champion names unique
champ.names <- unique(champ.names)

# url for NBA team names and coordinates
city.url <- 'https://en.wikipedia.org/wiki/National_Basketball_Association'

# read html
city.page <- read_html(city.url)

# initalize empty list
champ.city <- list()

# champ.city <- c(city.page %>% html_nodes("table") %>% .[3] %>% html_nodes("tr") %>% .[4] %>% 
#     html_nodes("td") %>% .[1] %>% html_text(),
#   # coords
#   city.page %>% html_nodes("table") %>% .[3] %>% html_nodes("tr") %>% .[4] %>% 
#     html_nodes("td") %>% .[5] %>% html_nodes("span") %>% .[11] %>% html_text())

# grabs team and coords from first table
k = 3
# 4-18
for (i in 1:15){
                         # team name
  champ.city[i] <- paste(city.page %>% html_nodes("table") %>% .[3] %>% html_nodes("tr") %>% .[k] %>% 
                         html_nodes("td") %>% .[1] %>% html_text(),
                         # coords
                         city.page %>% html_nodes("table") %>% .[3] %>% html_nodes("tr") %>% .[k] %>% 
                         html_nodes("td") %>% .[5] %>% html_nodes("span") %>% .[11] %>% html_text())
  k <- k + 1

}  

# grabs team and coords from second table
j = 19
# 19-34
for (i in 16:30){
                         # team name
  champ.city[i] <- paste(city.page %>% html_nodes("table") %>% .[3] %>% html_nodes("tr") %>% .[j] %>% 
                          html_nodes("td") %>% .[1] %>% html_text(),
                         # coords
                         city.page %>% html_nodes("table") %>% .[3] %>% html_nodes("tr") %>% .[j] %>% 
                          html_nodes("td") %>% .[5] %>% html_nodes("span") %>% .[11] %>% html_text())
  j <- j + 1                         
}

# split strings on \n
champ.split <- sapply(champ.city, function(x) strsplit(x, "\n"))

# initalize empty lists
names <- list()
coords <- list()

# creates separate lists from team names and coordinates
for (i in 1:length(champ.split)){
  names[i] <- champ.split[[i]][1]
  coords[i] <- champ.split[[i]][2]
}

# replace semi colon with colon
coords <- stri_replace_first_charclass(coords, "[;]", ":")

# remove leading space and space after colon
coords <- gsub(" ", "", coords)

# flatten list of names
names <- unlist(names)

# static set of winners and coords
# toronto      '43.643333:79.379167'
# golden state '37.768056:122.3875'
# cleveland    '41.496389:81.688056'
# san antonio  '29.426944:98.4375'
# miami        '25.781389:80.188056'
# dallas       '32.790556:96.810278'
# lakers       '34.043056:118.267222'
# boston       '42.366303:71.062228'
# detroit      '42.696944:83.245556'

# coords <- c('43.643333:-79.379167', '37.768056:-122.3875', '41.496389:-81.688056',
#             '29.426944:-98.4375', '25.781389:-80.188056', '32.790556:-96.810278',
#             '34.043056:-118.267222', '42.366303:-71.062228', '42.696944:-83.245556')


# all teams and their coordinates as separate columns in a df
full.df <- data.frame(team = names, coords = coords)

# creates a df for just the champion teams
map.df <- data.frame(LatLong = full.df[full.df$team %in% champ.names,][2], 
                     Tip = full.df[full.df$team %in% champ.names,][1])

# setup map
champMap <- gvisMap(map.df,
                    locationvar = 'coords',
                    tipvar = 'team',
                    options=list(showTip=TRUE, 
                                  showLine=TRUE, 
                                  enableScrollWheel=TRUE,
                                  mapType='terrain', 
                                  useMapTypeControl=TRUE))
# draw map
plot(champMap)


```
### a) Select a league and a season
I chose to collect and analyse data from the 2003-2004 season of the NBA.



```{r echo = FALSE}
# quick view at the full stats table
head(NBA.Stats)
```

### Dataset Summary
This dataset consists of 1.5M beer reviews from the website Beeradvocate.com. The set includes various pieces of information about the beer and the reviewers impressions of the taste. I chose to focus my analysis on the ABV, beer name, beer style and the overall impression categories.

Source - https://data.world/socialmediadata/beeradvocate

### At a glance
Prior to performing any analysis I chose to do some cleaning of the dataset. I noticed there were a large number of beers with only 1 review. I took these as being reviewed erroneously due to a spelling error in the beers name or some other mistake by the user. Prior to removing these from the dataset there was a total of ~57K unique beers with an average of 28 reviews per beer. After removing all beers with a single review the total distinct beers sits at ~38K with an average of 41 reviews per beer. The average ABV across the dataset is 7.1 and the max is 43, that's one seriously strong beer!

```{r echo = FALSE}
# Basic stats table
stat.table
```

### Top 10 by ABV
Since I just spoke about ABV's, lets dive a little deeper into that category of the data. The following is a table displaying the 10 top ABV's determined by the total number of beers reviewed with that ABV.

Clocking in almost twice as many reviews as number two are beers with an ABV of 5%. Some of the most notable beers in this category are Budweiser, Stella Artois, Heineken and Miller Highlife. These beers are all highly available in many stores and bars, so it's no wonder they have so many reviews! 

While 5% may be the most reviewed, it's actually the worst in terms of average rating with a score of 3.64. The highest average rating is 9% ABV with a score of 3.96, followed by 7.5% at 3.94, then a three way tie between 7%, 8% and 10% at 3.93.

Another interesting tidbit is that these top 10 ABV's make up 38.3% of the total dataset!
```{r}
paste(round(sum(abv.top10) / nrow(beer) * 100, digits = 1), "%", sep = '')
```

```{r echo = FALSE}
# top 10 by abv table
abv.table
```

### Top 10 beers by name

Let's shift focus now and move over to the top 10 beers by name determined by the total number of reviews.

As you can see from the chart below, Sierra Nevada brewing managed to achieve two different beers in the top 10 with their Celebration Ale coming in at number 3 with 3000 reviews and their Pale Ale at number 7 with almost 2600. 

All 10 of these beers scored above a 4.0 average in the overall impression category with the lowest being the Arrogant Bastard ale from Stone brewing at 4.1 and the highest being Pliny The Elder from Russian River Brewing at 4.6.

```{r echo = FALSE}
# most reviewed beer by name
plot.top10.name
```

### Top 10 beers by style

Next up is our top 10 most reviewed beers by style. Our front runner here by over 30K reviews is the American IPA style with ~117K reviews, followed up by the double IPA at ~86K. The average review rating in this category is more diverse than the previous with the highest average being the American Double or Imperial Stout coming in at 4.03, and last place being the Fruit or Vegetable beer getting an average overall impression score of 3.42, a spread of 0.61 compared to 0.5 for the previous category.

```{r echo = FALSE}
# Draw Top 10 most Reviews by style bar graph
plot.top10.style
```

### ABV Distribution by style

Diving into the ABV distributions for the top 10 styles, we can see there are some pretty large differences between the group. Each has a slightly different quantile range and number of outliers. 

The American Pale, IPA and Porter all have a short box indicating their inter-quartile range is relatively small. While on the other hand the American Strong Ale and the Imperial Stout both have a tall box, indicating their average range is larger. These are also the only two styles that do not have any outliers below their lower whisker.

Both the Imperial Stout and Imperial IPA have the widest range at over a 30 point difference between their minimum and maximum ABV. 

```{r echo = FALSE, warning = FALSE}
# Top 10 by style with ABV boxplot
abv.box
```

### Overall rating distribution
Looking at the distribution for the rating provided by users in the "overall review" column we see the data is left skewed with the largest portions residing between 3.5-4.5 and 4 being the peak at nearly twice as high as 3.5 or 4.5.

```{r echo = FALSE}
# review breakdown table and chart creation
plot.review
```

### Central Limit Theorem
Let's further investigate this data by applying the central limit theorem. This theorem states that even if a distribution of sample means is not normally distributed, their normalized sums tends toward a normal distribution. This means that as the sample size increases and the sums are normalized, the distribution will also become more and more normalized. 

Below are four histograms created using 1000 random samples from the "overall review" data with a sample size of 10, 50, 100 and 200. As the sample size increases the distribution becomes increasingly normalized, forming a bell shaped curve.

```{r echo = FALSE}
cat("population mean: ", round(mean(beer$review_overall), digits = 1),
      " sd: " ,round(sd(beer$review_overall),digits = 2),
      "\nSample size 10, mean: ", round(mean(xbar.1k10), digits = 1),
      " sd: " ,round(sd(xbar.1k10),digits = 2), 
      "\nSample size 50, mean: ", round(mean(xbar.1k20), digits = 1),
      " sd: " ,round(sd(xbar.1k20),digits = 2),
      "\nSample size 100, mean: ", round(mean(xbar.1k30), digits = 1),
      " sd: " ,round(sd(xbar.1k30),digits = 2), 
      "\nSample size 200, mean: ", round(mean(xbar.1k40), digits = 1),
      " sd: " ,round(sd(xbar.1k40),digits = 2),sep = '')
```

```{r echo = FALSE}
# Draw samples and hisgrams on overall_review ratings
subplot(k10, k20, k30, k40, nrows = 2) %>% 
  layout(title = "Overall Review Distribution")
```

### Sampling of review ratings
By utilizing sampling techniques we are able to extract portions of a datasets to test theories or perform analysis work without having to utilize the entire dataset, all while maintaining the proportions of the original data. This can prove to be invaluable when the original dataset is too large to process for one reason or another. Care needs to be taken to ensure that the sampling methods used maintains a similar distribution as the original dataset or the analysis results could be severely skewed.

Below I show charts based upon the "overall review" data using the original data and three different sampling techniques. Simple Random sampling without replacement, Systematic Sampling and stratified sampling.

Simple Random without Replacement randomly selects from the dataset and does not return the data back to the set to be chosen again. This ensures each row selected will be unique and will not cause the sample to be skewed.

Systematic sampling selects a number which will represent the first item to be included in the sample, then utilizes a sampling interval which determines how many items to skip over before selecting the next item for the sample. This is continued until the end of the population is reached.

The last method is stratified sampling. First the population is divided into mutually exclusive sub-groups and from within those groups, members are randomly chosen to participate in the sample.

Please note that each chart appears very similar in shape, but the number of samples taken for each is drastically different. The original dataset has 1.56M rows, but only 250K were used for systematic, 30K for Simple random sampling without replacement and 1k for stratified sampling. 

While the shapes are very similar, upon closer inspection you can see that there are some variances. Within the systematic sampling chart the 3.5 value is only ~43K but the 4.5 is ~60k. On all of the other charts these two very close to being the same number. As I mentioned before sampling can prove to be invaluable when a dataset is simply too large to work with, but caution needs to be exercised as it can cause proportional skewing.

```{r echo = FALSE}
# Draw plots for all sampling methods
subplot(plot.nosample, plot.samp.wor, plot.samp.syst, plot.samp.strat, nrows = 2)
```

### Conclusion
This is a large and diverse dataset with many avenues to explore beyond what I touched upon in this report. I could see this data being used for data mining or predictive analytics to help breweries reach new customers who have liked other similar beers, or perhaps to brew a new beer in a popular style or ABV where they do not currently have a product.  
<br>
<br>
<br>
<br>